{"ast":null,"code":"var gp12pem = require('google-p12-pem');\n\nvar request = require('request');\n\nvar mime = require('mime');\n\nvar jws = require('jws');\n\nvar fs = require('fs');\n\nvar GOOGLE_TOKEN_URL = 'https://accounts.google.com/o/oauth2/token';\nvar GOOGLE_REVOKE_TOKEN_URL = 'https://accounts.google.com/o/oauth2/revoke?token=';\n/**\n * Create a GoogleToken.\n *\n * @param {object}   options  Configuration object.\n */\n\nfunction GoogleToken(options) {\n  if (!(this instanceof GoogleToken)) {\n    return new GoogleToken(options);\n  }\n\n  this._configure(options);\n}\n\nGoogleToken.prototype._mime = mime;\n/**\n * Returns whether the token has expired.\n *\n * @return {Boolean} true if the token has expired, false otherwise.\n */\n\nGoogleToken.prototype.hasExpired = function () {\n  var now = new Date().getTime();\n\n  if (this.token && this.expires_at) {\n    return now >= this.expires_at;\n  } else {\n    return true;\n  }\n};\n\nGoogleToken.prototype._gp12pem = gp12pem;\n/**\n * Returns a cached token or retrieves a new one from Google.\n *\n * @param  {Function} callback The callback function.\n */\n\nGoogleToken.prototype.getToken = function (callback) {\n  var self = this;\n\n  if (!this.hasExpired()) {\n    return callback(null, this.token);\n  } else {\n    if (!this.key && !this.keyFile) {\n      callback(new Error('No key or keyFile set.'));\n      return;\n    } else if (!this.key && this.keyFile) {\n      var mimeType = this._mime.lookup(this.keyFile);\n\n      if (mimeType === 'application/json') {\n        // json file\n        fs.readFile(this.keyFile, handleJSONKey);\n      } else {\n        // Must be a .p12 file or .pem key\n        if (!self.iss) {\n          var error = new Error('email is required.');\n          error.code = 'MISSING_CREDENTIALS';\n          callback(error);\n          return;\n        }\n\n        if (mimeType === 'application/x-pkcs12') {\n          // convert to .pem on the fly\n          self._gp12pem(this.keyFile, handleKey);\n        } else {\n          // assume .pem key otherwise\n          fs.readFile(this.keyFile, handleKey);\n        }\n      }\n    } else {\n      return this._requestToken(callback);\n    }\n  }\n\n  function handleJSONKey(err, key) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    try {\n      var body = JSON.parse(key);\n      self.key = body.private_key;\n      self.iss = body.client_email;\n    } catch (e) {\n      callback(e);\n      return;\n    }\n\n    if (!self.key || !self.iss) {\n      var error = new Error('private_key and client_email are required.');\n      error.code = 'MISSING_CREDENTIALS';\n      callback(error);\n      return;\n    }\n\n    self._requestToken(callback);\n  }\n\n  function handleKey(err, key) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    self.key = key;\n\n    self._requestToken(callback);\n  }\n};\n/**\n * Revoke the token if one is set.\n *\n * @param  {Function} callback The callback function.\n */\n\n\nGoogleToken.prototype.revokeToken = function (callback) {\n  var self = this;\n\n  if (this.token) {\n    this._request(GOOGLE_REVOKE_TOKEN_URL + this.token, function (err, res) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      self._configure({\n        email: self.iss,\n        sub: self.sub,\n        key: self.key,\n        keyFile: self.keyFile,\n        scope: self.scope\n      });\n\n      callback();\n    });\n  } else {\n    callback(new Error('No token to revoke.'));\n  }\n};\n/**\n * Configure the GoogleToken for re-use.\n * @param  {object} options Configuration object.\n */\n\n\nGoogleToken.prototype._configure = function (options) {\n  var self = this;\n  options = options || {};\n  this.keyFile = options.keyFile;\n  this.key = options.key;\n  this._request = request;\n  this.token = this.expires_at = this.raw_token = null;\n  this.iss = options.email || options.iss;\n\n  if (options.sub) {\n    this.sub = options.sub;\n  }\n\n  if (typeof options.scope === 'object') {\n    this.scope = options.scope.join(' ');\n  } else {\n    this.scope = options.scope;\n  }\n};\n/**\n * Request the token from Google.\n *\n * @param  {Function} callback The callback function.\n */\n\n\nGoogleToken.prototype._requestToken = function (callback) {\n  var self = this;\n  var iat = Math.floor(new Date().getTime() / 1000);\n  var payload = {\n    iss: this.iss,\n    scope: this.scope,\n    aud: GOOGLE_TOKEN_URL,\n    exp: iat + 3600,\n    // 3600 seconds = 1 hour\n    iat: iat\n  };\n\n  if (this.sub) {\n    payload.sub = this.sub;\n  }\n\n  var toSign = {\n    header: {\n      alg: 'RS256',\n      typ: 'JWT'\n    },\n    payload: payload,\n    secret: this.key\n  };\n  return this._signJWT(toSign, function (err, signedJWT) {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    return self._request({\n      method: 'post',\n      url: GOOGLE_TOKEN_URL,\n      form: {\n        grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n        assertion: signedJWT\n      }\n    }, function (err, res, body) {\n      try {\n        body = JSON.parse(body);\n      } catch (e) {\n        body = {};\n      }\n\n      err = err || body.error && new Error(body.error + (body.error_description ? ': ' + body.error_description : ''));\n\n      if (err) {\n        self.token = null;\n        self.token_expires = null;\n        callback(err, null);\n        return;\n      }\n\n      self.raw_token = body;\n      self.token = body.access_token;\n      self.expires_at = (iat + body.expires_in) * 1000;\n      return callback(null, self.token);\n    });\n  });\n};\n/**\n * Sign the JWT object, returning any errors in the callback.\n *\n * @param  {object}   opts     The configuration object.\n * @param  {Function} callback The callback function.\n */\n\n\nGoogleToken.prototype._signJWT = function (opts, callback) {\n  try {\n    var signedJWT = jws.sign(opts);\n    return callback(null, signedJWT);\n  } catch (err) {\n    callback(err, null);\n  }\n};\n\nmodule.exports = GoogleToken;","map":null,"metadata":{},"sourceType":"script"}