{"ast":null,"code":"var async = require(\"async\");\n\nvar _request = require(\"request\");\n\nvar xml2js = require(\"xml2js\");\n\nvar http = require(\"http\");\n\nvar querystring = require(\"querystring\");\n\nvar _ = require('lodash');\n\nvar GoogleAuth = require(\"google-auth-library\");\n\nvar GOOGLE_FEED_URL = \"https://spreadsheets.google.com/feeds/\";\nvar GOOGLE_AUTH_SCOPE = [\"https://spreadsheets.google.com/feeds\"];\nvar REQUIRE_AUTH_MESSAGE = 'You must authenticate to modify sheet data'; // The main class that represents a single sheet\n// this is the main module.exports\n\nvar GoogleSpreadsheet = function GoogleSpreadsheet(ss_key, auth_id, options) {\n  var self = this;\n  var google_auth = null;\n  var visibility = 'public';\n  var projection = 'values';\n  var auth_mode = 'anonymous';\n  var auth_client = new GoogleAuth();\n  var jwt_client;\n  options = options || {};\n  var xml_parser = new xml2js.Parser({\n    // options carried over from older version of xml2js\n    // might want to update how the code works, but for now this is fine\n    explicitArray: false,\n    explicitRoot: false\n  });\n\n  if (!ss_key) {\n    throw new Error(\"Spreadsheet key not provided.\");\n  } // auth_id may be null\n\n\n  setAuthAndDependencies(auth_id); // Authentication Methods\n\n  this.setAuthToken = function (auth_id) {\n    if (auth_mode == 'anonymous') auth_mode = 'token';\n    setAuthAndDependencies(auth_id);\n  }; // deprecated username/password login method\n  // leaving it here to help notify users why it doesn't work\n\n\n  this.setAuth = function (username, password, cb) {\n    return cb(new Error('Google has officially deprecated ClientLogin. Please upgrade this module and see the readme for more instrucations'));\n  };\n\n  this.useServiceAccountAuth = function (creds, cb) {\n    if (typeof creds == 'string') {\n      try {\n        creds = require(creds);\n      } catch (err) {\n        return cb(err);\n      }\n    }\n\n    jwt_client = new auth_client.JWT(creds.client_email, null, creds.private_key, GOOGLE_AUTH_SCOPE, null);\n    renewJwtAuth(cb);\n  };\n\n  function renewJwtAuth(cb) {\n    auth_mode = 'jwt';\n    jwt_client.authorize(function (err, token) {\n      if (err) return cb(err);\n      self.setAuthToken({\n        type: token.token_type,\n        value: token.access_token,\n        expires: token.expiry_date\n      });\n      cb();\n    });\n  }\n\n  this.isAuthActive = function () {\n    return !!google_auth;\n  };\n\n  function setAuthAndDependencies(auth) {\n    google_auth = auth;\n\n    if (!options.visibility) {\n      visibility = google_auth ? 'private' : 'public';\n    }\n\n    if (!options.projection) {\n      projection = google_auth ? 'full' : 'values';\n    }\n  } // This method is used internally to make all requests\n\n\n  this.makeFeedRequest = function (url_params, method, query_or_data, cb) {\n    var url;\n    var headers = {};\n    if (!cb) cb = function cb() {};\n\n    if (typeof url_params == 'string') {\n      // used for edit / delete requests\n      url = url_params;\n    } else if (Array.isArray(url_params)) {\n      //used for get and post requets\n      url_params.push(visibility, projection);\n      url = GOOGLE_FEED_URL + url_params.join(\"/\");\n    }\n\n    async.series({\n      auth: function auth(step) {\n        if (auth_mode != 'jwt') return step(); // check if jwt token is expired\n\n        if (google_auth && google_auth.expires > +new Date()) return step();\n        renewJwtAuth(step);\n      },\n      request: function request(result, step) {\n        if (google_auth) {\n          if (google_auth.type === 'Bearer') {\n            headers['Authorization'] = 'Bearer ' + google_auth.value;\n          } else {\n            headers['Authorization'] = \"GoogleLogin auth=\" + google_auth;\n          }\n        }\n\n        headers['Gdata-Version'] = '3.0';\n\n        if (method == 'POST' || method == 'PUT') {\n          headers['content-type'] = 'application/atom+xml';\n        }\n\n        if (method == 'PUT' || method == 'POST' && url.indexOf('/batch') != -1) {\n          headers['If-Match'] = '*';\n        }\n\n        if (method == 'GET' && query_or_data) {\n          var query = \"?\" + querystring.stringify(query_or_data); // replacements are needed for using structured queries on getRows\n\n          query = query.replace(/%3E/g, '>');\n          query = query.replace(/%3D/g, '=');\n          query = query.replace(/%3C/g, '<');\n          url += query;\n        }\n\n        _request({\n          url: url,\n          method: method,\n          headers: headers,\n          body: method == 'POST' || method == 'PUT' ? query_or_data : null\n        }, function (err, response, body) {\n          if (err) {\n            return cb(err);\n          } else if (response.statusCode === 401) {\n            return cb(new Error(\"Invalid authorization key.\"));\n          } else if (response.statusCode >= 400) {\n            var message = _.isObject(body) ? JSON.stringify(body) : body.replace(/&quot;/g, '\"');\n            return cb(new Error(\"HTTP error \" + response.statusCode + \" (\" + http.STATUS_CODES[response.statusCode]) + \") - \" + message);\n          } else if (response.statusCode === 200 && response.headers['content-type'].indexOf('text/html') >= 0) {\n            return cb(new Error(\"Sheet is private. Use authentication or make public. (see https://github.com/theoephraim/node-google-spreadsheet#a-note-on-authentication for details)\"));\n          }\n\n          if (body) {\n            xml_parser.parseString(body, function (err, result) {\n              if (err) return cb(err);\n              cb(null, result, body);\n            });\n          } else {\n            if (err) cb(err);else cb(null, true);\n          }\n        });\n      }\n    });\n  }; // public API methods\n\n\n  this.getInfo = function (cb) {\n    self.makeFeedRequest([\"worksheets\", ss_key], 'GET', null, function (err, data, xml) {\n      if (err) return cb(err);\n\n      if (data === true) {\n        return cb(new Error('No response to getInfo call'));\n      }\n\n      var ss_data = {\n        id: data.id,\n        title: data.title,\n        updated: data.updated,\n        author: data.author,\n        worksheets: []\n      };\n      var worksheets = forceArray(data.entry);\n      worksheets.forEach(function (ws_data) {\n        ss_data.worksheets.push(new SpreadsheetWorksheet(self, ws_data));\n      });\n      self.info = ss_data;\n      self.worksheets = ss_data.worksheets;\n      cb(null, ss_data);\n    });\n  }; // NOTE: worksheet IDs start at 1\n\n\n  this.addWorksheet = function (opts, cb) {\n    // make opts optional\n    if (typeof opts == 'function') {\n      cb = opts;\n      opts = {};\n    }\n\n    cb = cb || _.noop;\n    if (!this.isAuthActive()) return cb(new Error(REQUIRE_AUTH_MESSAGE));\n    var defaults = {\n      title: 'Worksheet ' + +new Date(),\n      // need a unique title\n      rowCount: 50,\n      colCount: 20\n    };\n\n    var opts = _.extend({}, defaults, opts); // if column headers are set, make sure the sheet is big enough for them\n\n\n    if (opts.headers && opts.headers.length > opts.colCount) {\n      opts.colCount = opts.headers.length;\n    }\n\n    var data_xml = '<entry xmlns=\"http://www.w3.org/2005/Atom\" xmlns:gs=\"http://schemas.google.com/spreadsheets/2006\"><title>' + opts.title + '</title><gs:rowCount>' + opts.rowCount + '</gs:rowCount><gs:colCount>' + opts.colCount + '</gs:colCount></entry>';\n    self.makeFeedRequest([\"worksheets\", ss_key], 'POST', data_xml, function (err, data, xml) {\n      if (err) return cb(err);\n      var sheet = new SpreadsheetWorksheet(self, data);\n      self.worksheets = self.worksheets || [];\n      self.worksheets.push(sheet);\n      sheet.setHeaderRow(opts.headers, function (err) {\n        cb(err, sheet);\n      });\n    });\n  };\n\n  this.removeWorksheet = function (sheet_id, cb) {\n    if (!this.isAuthActive()) return cb(new Error(REQUIRE_AUTH_MESSAGE));\n    if (sheet_id instanceof SpreadsheetWorksheet) return sheet_id.del(cb);\n    self.makeFeedRequest(GOOGLE_FEED_URL + \"worksheets/\" + ss_key + \"/private/full/\" + sheet_id, 'DELETE', null, cb);\n  };\n\n  this.getRows = function (worksheet_id, opts, cb) {\n    // the first row is used as titles/keys and is not included\n    // opts is optional\n    if (typeof opts == 'function') {\n      cb = opts;\n      opts = {};\n    }\n\n    var query = {};\n    if (opts.offset) query[\"start-index\"] = opts.offset;else if (opts.start) query[\"start-index\"] = opts.start;\n    if (opts.limit) query[\"max-results\"] = opts.limit;else if (opts.num) query[\"max-results\"] = opts.num;\n    if (opts.orderby) query[\"orderby\"] = opts.orderby;\n    if (opts.reverse) query[\"reverse\"] = 'true';\n    if (opts.query) query['sq'] = opts.query;\n    self.makeFeedRequest([\"list\", ss_key, worksheet_id], 'GET', query, function (err, data, xml) {\n      if (err) return cb(err);\n\n      if (data === true) {\n        return cb(new Error('No response to getRows call'));\n      } // gets the raw xml for each entry -- this is passed to the row object so we can do updates on it later\n\n\n      var entries_xml = xml.match(/<entry[^>]*>([\\s\\S]*?)<\\/entry>/g); // need to add the properties from the feed to the xml for the entries\n\n      var feed_props = _.clone(data.$);\n\n      delete feed_props['gd:etag'];\n\n      var feed_props_str = _.reduce(feed_props, function (str, val, key) {\n        return str + key + '=\\'' + val + '\\' ';\n      }, '');\n\n      entries_xml = _.map(entries_xml, function (xml) {\n        return xml.replace('<entry ', '<entry ' + feed_props_str);\n      });\n      var rows = [];\n      var entries = forceArray(data.entry);\n      var i = 0;\n      entries.forEach(function (row_data) {\n        rows.push(new SpreadsheetRow(self, row_data, entries_xml[i++]));\n      });\n      cb(null, rows);\n    });\n  };\n\n  this.addRow = function (worksheet_id, data, cb) {\n    var data_xml = '<entry xmlns=\"http://www.w3.org/2005/Atom\" xmlns:gsx=\"http://schemas.google.com/spreadsheets/2006/extended\">' + \"\\n\";\n    Object.keys(data).forEach(function (key) {\n      if (key != 'id' && key != 'title' && key != 'content' && key != '_links') {\n        data_xml += '<gsx:' + xmlSafeColumnName(key) + '>' + xmlSafeValue(data[key]) + '</gsx:' + xmlSafeColumnName(key) + '>' + \"\\n\";\n      }\n    });\n    data_xml += '</entry>';\n    self.makeFeedRequest([\"list\", ss_key, worksheet_id], 'POST', data_xml, function (err, data, new_xml) {\n      if (err) return cb(err);\n      var entries_xml = new_xml.match(/<entry[^>]*>([\\s\\S]*?)<\\/entry>/g);\n      var row = new SpreadsheetRow(self, data, entries_xml[0]);\n      cb(null, row);\n    });\n  };\n\n  this.getCells = function (worksheet_id, opts, cb) {\n    // opts is optional\n    if (typeof opts == 'function') {\n      cb = opts;\n      opts = {};\n    } // Supported options are:\n    // min-row, max-row, min-col, max-col, return-empty\n\n\n    var query = _.assign({}, opts);\n\n    self.makeFeedRequest([\"cells\", ss_key, worksheet_id], 'GET', query, function (err, data, xml) {\n      if (err) return cb(err);\n\n      if (data === true) {\n        return cb(new Error('No response to getCells call'));\n      }\n\n      var cells = [];\n      var entries = forceArray(data['entry']);\n      var i = 0;\n      entries.forEach(function (cell_data) {\n        cells.push(new SpreadsheetCell(self, worksheet_id, cell_data));\n      });\n      cb(null, cells);\n    });\n  };\n}; // Classes\n\n\nvar SpreadsheetWorksheet = function SpreadsheetWorksheet(spreadsheet, data) {\n  var self = this;\n  var links;\n  self.url = data.id;\n  self.id = data.id.substring(data.id.lastIndexOf(\"/\") + 1);\n  self.title = data.title;\n  self.rowCount = parseInt(data['gs:rowCount']);\n  self.colCount = parseInt(data['gs:colCount']);\n  self['_links'] = [];\n  links = forceArray(data.link);\n  links.forEach(function (link) {\n    self['_links'][link['$']['rel']] = link['$']['href'];\n  });\n  self['_links']['cells'] = self['_links']['http://schemas.google.com/spreadsheets/2006#cellsfeed'];\n  self['_links']['bulkcells'] = self['_links']['cells'] + '/batch';\n\n  function _setInfo(opts, cb) {\n    cb = cb || _.noop;\n    var xml = '' + '<entry xmlns=\"http://www.w3.org/2005/Atom\" xmlns:gs=\"http://schemas.google.com/spreadsheets/2006\">' + '<title>' + (opts.title || self.title) + '</title>' + '<gs:rowCount>' + (opts.rowCount || self.rowCount) + '</gs:rowCount>' + '<gs:colCount>' + (opts.colCount || self.colCount) + '</gs:colCount>' + '</entry>';\n    spreadsheet.makeFeedRequest(self['_links']['edit'], 'PUT', xml, function (err, response) {\n      if (err) return cb(err);\n      self.title = response.title;\n      self.rowCount = parseInt(response['gs:rowCount']);\n      self.colCount = parseInt(response['gs:colCount']);\n      cb();\n    });\n  }\n\n  this.resize = _setInfo;\n\n  this.setTitle = function (title, cb) {\n    _setInfo({\n      title: title\n    }, cb);\n  }; // just a convenience method to clear the whole sheet\n  // resizes to 1 cell, clears the cell, and puts it back\n\n\n  this.clear = function (cb) {\n    var cols = self.colCount;\n    var rows = self.colCount;\n    self.resize({\n      rowCount: 1,\n      colCount: 1\n    }, function (err) {\n      if (err) return cb(err);\n      self.getCells(function (err, cells) {\n        cells[0].setValue(null, function (err) {\n          if (err) return cb(err);\n          self.resize({\n            rowCount: rows,\n            colCount: cols\n          }, cb);\n        });\n      });\n    });\n  };\n\n  this.getRows = function (opts, cb) {\n    spreadsheet.getRows(self.id, opts, cb);\n  };\n\n  this.getCells = function (opts, cb) {\n    spreadsheet.getCells(self.id, opts, cb);\n  };\n\n  this.addRow = function (data, cb) {\n    spreadsheet.addRow(self.id, data, cb);\n  };\n\n  this.bulkUpdateCells = function (cells, cb) {\n    if (!cb) cb = function cb() {};\n    var entries = cells.map(function (cell, i) {\n      cell._needsSave = false;\n      return \"<entry>\\n        <batch:id>\" + cell.batchId + \"</batch:id>\\n        <batch:operation type=\\\"update\\\"/>\\n        <id>\" + self['_links']['cells'] + '/' + cell.batchId + \"</id>\\n        <link rel=\\\"edit\\\" type=\\\"application/atom+xml\\\"\\n          href=\\\"\" + cell._links.edit + \"\\\"/>\\n        <gs:cell row=\\\"\" + cell.row + \"\\\" col=\\\"\" + cell.col + \"\\\" inputValue=\\\"\" + cell.valueForSave + \"\\\"/>\\n      </entry>\";\n    });\n    var data_xml = \"<feed xmlns=\\\"http://www.w3.org/2005/Atom\\\"\\n      xmlns:batch=\\\"http://schemas.google.com/gdata/batch\\\"\\n      xmlns:gs=\\\"http://schemas.google.com/spreadsheets/2006\\\">\\n      <id>\" + self['_links']['cells'] + \"</id>\\n      \" + entries.join(\"\\n\") + \"\\n    </feed>\";\n    spreadsheet.makeFeedRequest(self['_links']['bulkcells'], 'POST', data_xml, function (err, data) {\n      if (err) return cb(err); // update all the cells\n\n      var cells_by_batch_id = _.keyBy(cells, 'batchId');\n\n      if (data.entry && data.entry.length) data.entry.forEach(function (cell_data) {\n        cells_by_batch_id[cell_data['batch:id']].updateValuesFromResponseData(cell_data);\n      });\n      cb();\n    });\n  };\n\n  this.del = function (cb) {\n    spreadsheet.makeFeedRequest(self['_links']['edit'], 'DELETE', null, cb);\n  };\n\n  this.setHeaderRow = function (values, cb) {\n    if (!cb) cb = function cb() {};\n    if (!values) return cb();\n\n    if (values.length > self.colCount) {\n      return cb(new Error('Sheet is not large enough to fit ' + values.length + ' columns. Resize the sheet first.'));\n    }\n\n    self.getCells({\n      'min-row': 1,\n      'max-row': 1,\n      'min-col': 1,\n      'max-col': self.colCount,\n      'return-empty': true\n    }, function (err, cells) {\n      if (err) return cb(err);\n\n      _.each(cells, function (cell) {\n        cell.value = values[cell.col - 1] ? values[cell.col - 1] : '';\n      });\n\n      self.bulkUpdateCells(cells, cb);\n    });\n  };\n};\n\nvar SpreadsheetRow = function SpreadsheetRow(spreadsheet, data, xml) {\n  var self = this;\n  self['_xml'] = xml;\n  Object.keys(data).forEach(function (key) {\n    var val = data[key];\n\n    if (key.substring(0, 4) === \"gsx:\") {\n      if (typeof val === 'object' && Object.keys(val).length === 0) {\n        val = null;\n      }\n\n      if (key == \"gsx:\") {\n        self[key.substring(0, 3)] = val;\n      } else {\n        self[key.substring(4)] = val;\n      }\n    } else {\n      if (key == \"id\") {\n        self[key] = val;\n      } else if (val['_']) {\n        self[key] = val['_'];\n      } else if (key == 'link') {\n        self['_links'] = [];\n        val = forceArray(val);\n        val.forEach(function (link) {\n          self['_links'][link['$']['rel']] = link['$']['href'];\n        });\n      }\n    }\n  }, this);\n\n  self.save = function (cb) {\n    /*\n    API for edits is very strict with the XML it accepts\n    So we just do a find replace on the original XML.\n    It's dumb, but I couldnt get any JSON->XML conversion to work reliably\n    */\n    var data_xml = self['_xml']; // probably should make this part more robust?\n\n    data_xml = data_xml.replace('<entry>', \"<entry xmlns='http://www.w3.org/2005/Atom' xmlns:gsx='http://schemas.google.com/spreadsheets/2006/extended'>\");\n    Object.keys(self).forEach(function (key) {\n      if (key.substr(0, 1) != '_' && typeof (self[key] == 'string')) {\n        data_xml = data_xml.replace(new RegExp('<gsx:' + xmlSafeColumnName(key) + \">([\\\\s\\\\S]*?)</gsx:\" + xmlSafeColumnName(key) + '>'), '<gsx:' + xmlSafeColumnName(key) + '>' + xmlSafeValue(self[key]) + '</gsx:' + xmlSafeColumnName(key) + '>');\n      }\n    });\n    spreadsheet.makeFeedRequest(self['_links']['edit'], 'PUT', data_xml, cb);\n  };\n\n  self.del = function (cb) {\n    spreadsheet.makeFeedRequest(self['_links']['edit'], 'DELETE', null, cb);\n  };\n};\n\nvar SpreadsheetCell = function SpreadsheetCell(spreadsheet, worksheet_id, data) {\n  var self = this;\n\n  function init() {\n    var links;\n    self.id = data['id'];\n    self.row = parseInt(data['gs:cell']['$']['row']);\n    self.col = parseInt(data['gs:cell']['$']['col']);\n    self.batchId = 'R' + self.row + 'C' + self.col;\n    self['_links'] = [];\n    links = forceArray(data.link);\n    links.forEach(function (link) {\n      self['_links'][link['$']['rel']] = link['$']['href'];\n    });\n    self.updateValuesFromResponseData(data);\n  }\n\n  self.updateValuesFromResponseData = function (_data) {\n    // formula value\n    var input_val = _data['gs:cell']['$']['inputValue']; // inputValue can be undefined so substr throws an error\n    // still unsure how this situation happens\n\n    if (input_val && input_val.substr(0, 1) === '=') {\n      self._formula = input_val;\n    } else {\n      self._formula = undefined;\n    } // numeric values\n\n\n    if (_data['gs:cell']['$']['numericValue'] !== undefined) {\n      self._numericValue = parseFloat(_data['gs:cell']['$']['numericValue']);\n    } else {\n      self._numericValue = undefined;\n    } // the main \"value\" - its always a string\n\n\n    self._value = _data['gs:cell']['_'] || '';\n  };\n\n  self.setValue = function (new_value, cb) {\n    self.value = new_value;\n    self.save(cb);\n  };\n\n  self._clearValue = function () {\n    self._formula = undefined;\n    self._numericValue = undefined;\n    self._value = '';\n  };\n\n  self.__defineGetter__('value', function () {\n    return self._value;\n  });\n\n  self.__defineSetter__('value', function (val) {\n    if (!val) return self._clearValue();\n    var numeric_val = parseFloat(val);\n\n    if (!isNaN(numeric_val)) {\n      self._numericValue = numeric_val;\n      self._value = val.toString();\n    } else {\n      self._numericValue = undefined;\n      self._value = val;\n    }\n\n    if (typeof val == 'string' && val.substr(0, 1) === '=') {\n      // use the getter to clear the value\n      self.formula = val;\n    } else {\n      self._formula = undefined;\n    }\n  });\n\n  self.__defineGetter__('formula', function () {\n    return self._formula;\n  });\n\n  self.__defineSetter__('formula', function (val) {\n    if (!val) return self._clearValue();\n\n    if (val.substr(0, 1) !== '=') {\n      throw new Error('Formulas must start with \"=\"');\n    }\n\n    self._numericValue = undefined;\n    self._value = '*SAVE TO GET NEW VALUE*';\n    self._formula = val;\n  });\n\n  self.__defineGetter__('numericValue', function () {\n    return self._numericValue;\n  });\n\n  self.__defineSetter__('numericValue', function (val) {\n    if (val === undefined || val === null) return self._clearValue();\n\n    if (isNaN(parseFloat(val)) || !isFinite(val)) {\n      throw new Error('Invalid numeric value assignment');\n    }\n\n    self._value = val.toString();\n    self._numericValue = parseFloat(val);\n    self._formula = undefined;\n  });\n\n  self.__defineGetter__('valueForSave', function () {\n    return xmlSafeValue(self._formula || self._value);\n  });\n\n  self.save = function (cb) {\n    if (!cb) cb = function cb() {};\n    self._needsSave = false;\n    var edit_id = 'https://spreadsheets.google.com/feeds/cells/key/worksheetId/private/full/R' + self.row + 'C' + self.col;\n    var data_xml = '<entry><id>' + self.id + '</id>' + '<link rel=\"edit\" type=\"application/atom+xml\" href=\"' + self.id + '\"/>' + '<gs:cell row=\"' + self.row + '\" col=\"' + self.col + '\" inputValue=\"' + self.valueForSave + '\"/></entry>';\n    data_xml = data_xml.replace('<entry>', \"<entry xmlns='http://www.w3.org/2005/Atom' xmlns:gs='http://schemas.google.com/spreadsheets/2006'>\");\n    spreadsheet.makeFeedRequest(self['_links']['edit'], 'PUT', data_xml, function (err, response) {\n      if (err) return cb(err);\n      self.updateValuesFromResponseData(response);\n      cb();\n    });\n  };\n\n  self.del = function (cb) {\n    self.setValue('', cb);\n  };\n\n  init();\n  return self;\n};\n\nmodule.exports = GoogleSpreadsheet; //utils\n\nvar forceArray = function forceArray(val) {\n  if (Array.isArray(val)) return val;\n  if (!val) return [];\n  return [val];\n};\n\nvar xmlSafeValue = function xmlSafeValue(val) {\n  if (val == null) return '';\n  return String(val).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/\\n/g, '&#10;').replace(/\\r/g, '&#13;');\n};\n\nvar xmlSafeColumnName = function xmlSafeColumnName(val) {\n  if (!val) return '';\n  return String(val).replace(/[\\s_]+/g, '').toLowerCase();\n};","map":null,"metadata":{},"sourceType":"script"}