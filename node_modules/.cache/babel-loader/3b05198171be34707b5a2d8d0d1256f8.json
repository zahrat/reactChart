{"ast":null,"code":"(function () {\n  'use strict';\n\n  var inNodeJS = typeof process !== 'undefined' && !process.browser;\n\n  var request = function requestNotProvided() {\n    throw new Error(\"The 'request' module is only available while running in Node.\");\n  };\n\n  if (inNodeJS) {\n    // This will get stripped out by Uglify, and Webpack will not include it\n    request = require('request');\n  }\n\n  var supportsCORS = false;\n  var inLegacyIE = false;\n\n  try {\n    var testXHR = new XMLHttpRequest();\n\n    if (typeof testXHR.withCredentials !== 'undefined') {\n      supportsCORS = true;\n    } else {\n      if ('XDomainRequest' in window) {\n        supportsCORS = true;\n        inLegacyIE = true;\n      }\n    }\n  } catch (e) {} // Create a simple indexOf function for support\n  // of older browsers.  Uses native indexOf if\n  // available.  Code similar to underscores.\n  // By making a separate function, instead of adding\n  // to the prototype, we will not break bad for loops\n  // in older browsers\n\n\n  var indexOfProto = Array.prototype.indexOf;\n\n  var ttIndexOf = function ttIndexOf(array, item) {\n    var i = 0,\n        l = array.length;\n\n    if (indexOfProto && array.indexOf === indexOfProto) {\n      return array.indexOf(item);\n    }\n\n    for (; i < l; i++) {\n      if (array[i] === item) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n  /*\n    Initialize with Tabletop.init( { key: '0AjAPaAU9MeLFdHUxTlJiVVRYNGRJQnRmSnQwTlpoUXc' } )\n      OR!\n    Initialize with Tabletop.init( { key: 'https://docs.google.com/spreadsheet/pub?hl=en_US&hl=en_US&key=0AjAPaAU9MeLFdHUxTlJiVVRYNGRJQnRmSnQwTlpoUXc&output=html&widget=true' } )\n      OR!\n    Initialize with Tabletop.init('0AjAPaAU9MeLFdHUxTlJiVVRYNGRJQnRmSnQwTlpoUXc')\n  */\n\n\n  var Tabletop = function Tabletop(options) {\n    // Make sure Tabletop is being used as a constructor no matter what.\n    if (!this || !(this instanceof Tabletop)) {\n      return new Tabletop(options);\n    }\n\n    if (typeof options === 'string') {\n      options = {\n        key: options\n      };\n    }\n\n    this.callback = options.callback;\n    this.wanted = options.wanted || [];\n    this.key = options.key;\n    this.simpleSheet = !!options.simpleSheet;\n    this.parseNumbers = !!options.parseNumbers;\n    this.wait = !!options.wait;\n    this.reverse = !!options.reverse;\n    this.postProcess = options.postProcess;\n    this.debug = !!options.debug;\n    this.query = options.query || '';\n    this.orderby = options.orderby;\n    this.endpoint = options.endpoint || 'https://spreadsheets.google.com';\n    this.singleton = !!options.singleton;\n    this.simpleUrl = !!(options.simpleUrl || options.simple_url); //jshint ignore:line\n\n    this.authkey = options.authkey;\n    this.sheetPrivacy = this.authkey ? 'private' : 'public';\n    this.callbackContext = options.callbackContext; // Default to on, unless there's a proxy, in which case it's default off\n\n    this.prettyColumnNames = typeof options.prettyColumnNames === 'undefined' ? !options.proxy : options.prettyColumnNames;\n\n    if (typeof options.proxy !== 'undefined') {\n      // Remove trailing slash, it will break the app\n      this.endpoint = options.proxy.replace(/\\/$/, '');\n      this.simpleUrl = true;\n      this.singleton = true; // Let's only use CORS (straight JSON request) when\n      // fetching straight from Google\n\n      supportsCORS = false;\n    }\n\n    this.parameterize = options.parameterize || false;\n\n    if (this.singleton) {\n      if (typeof Tabletop.singleton !== 'undefined') {\n        this.log('WARNING! Tabletop singleton already defined');\n      }\n\n      Tabletop.singleton = this;\n    }\n    /* Be friendly about what you accept */\n\n\n    if (/key=/.test(this.key)) {\n      this.log('You passed an old Google Docs url as the key! Attempting to parse.');\n      this.key = this.key.match('key=(.*?)(&|#|$)')[1];\n    }\n\n    if (/pubhtml/.test(this.key)) {\n      this.log('You passed a new Google Spreadsheets url as the key! Attempting to parse.');\n      this.key = this.key.match('d\\\\/(.*?)\\\\/pubhtml')[1];\n    }\n\n    if (/spreadsheets\\/d/.test(this.key)) {\n      this.log('You passed the most recent version of Google Spreadsheets url as the key! Attempting to parse.');\n      this.key = this.key.match('d\\\\/(.*?)\\/')[1];\n    }\n\n    if (!this.key) {\n      this.log('You need to pass Tabletop a key!');\n      return;\n    }\n\n    this.log('Initializing with key ' + this.key);\n    this.models = {};\n    this.modelNames = [];\n    this.model_names = this.modelNames; //jshint ignore:line\n\n    this.baseJsonPath = '/feeds/worksheets/' + this.key + '/' + this.sheetPrivacy + '/basic?alt=';\n\n    if (inNodeJS || supportsCORS) {\n      this.baseJsonPath += 'json';\n    } else {\n      this.baseJsonPath += 'json-in-script';\n    }\n\n    if (!this.wait) {\n      this.fetch();\n    }\n  }; // A global storage for callbacks.\n\n\n  Tabletop.callbacks = {}; // Backwards compatibility.\n\n  Tabletop.init = function (options) {\n    return new Tabletop(options);\n  };\n\n  Tabletop.sheets = function () {\n    this.log('Times have changed! You\\'ll want to use var tabletop = Tabletop.init(...); tabletop.sheets(...); instead of Tabletop.sheets(...)');\n  };\n\n  Tabletop.prototype = {\n    fetch: function fetch(callback) {\n      if (typeof callback !== 'undefined') {\n        this.callback = callback;\n      }\n\n      this.requestData(this.baseJsonPath, this.loadSheets);\n    },\n\n    /*\n      This will call the environment appropriate request method.\n       In browser it will use JSON-P, in node it will use request()\n    */\n    requestData: function requestData(path, callback) {\n      this.log('Requesting', path);\n\n      if (inNodeJS) {\n        this.serverSideFetch(path, callback);\n      } else {\n        //CORS only works in IE8/9 across the same protocol\n        //You must have your server on HTTPS to talk to Google, or it'll fall back on injection\n        var protocol = this.endpoint.split('//').shift() || 'http';\n\n        if (supportsCORS && (!inLegacyIE || protocol === location.protocol)) {\n          this.xhrFetch(path, callback);\n        } else {\n          this.injectScript(path, callback);\n        }\n      }\n    },\n\n    /*\n      Use Cross-Origin XMLHttpRequest to get the data in browsers that support it.\n    */\n    xhrFetch: function xhrFetch(path, callback) {\n      //support IE8's separate cross-domain object\n      var xhr = inLegacyIE ? new XDomainRequest() : new XMLHttpRequest();\n      xhr.open('GET', this.endpoint + path);\n      var self = this;\n\n      xhr.onload = function () {\n        var json;\n\n        try {\n          json = JSON.parse(xhr.responseText);\n        } catch (e) {\n          console.error(e);\n        }\n\n        callback.call(self, json);\n      };\n\n      xhr.send();\n    },\n\n    /*\n      Insert the URL into the page as a script tag. Once it's loaded the spreadsheet data\n      it triggers the callback. This helps you avoid cross-domain errors\n      http://code.google.com/apis/gdata/samples/spreadsheet_sample.html\n       Let's be plain-Jane and not use jQuery or anything.\n    */\n    injectScript: function injectScript(path, callback) {\n      var script = document.createElement('script');\n      var callbackName;\n\n      if (this.singleton) {\n        if (callback === this.loadSheets) {\n          callbackName = 'Tabletop.singleton.loadSheets';\n        } else if (callback === this.loadSheet) {\n          callbackName = 'Tabletop.singleton.loadSheet';\n        }\n      } else {\n        var self = this;\n        callbackName = 'tt' + +new Date() + Math.floor(Math.random() * 100000); // Create a temp callback which will get removed once it has executed,\n        // this allows multiple instances of Tabletop to coexist.\n\n        Tabletop.callbacks[callbackName] = function () {\n          var args = Array.prototype.slice.call(arguments, 0);\n          callback.apply(self, args);\n          script.parentNode.removeChild(script);\n          delete Tabletop.callbacks[callbackName];\n        };\n\n        callbackName = 'Tabletop.callbacks.' + callbackName;\n      }\n\n      var url = path + '&callback=' + callbackName;\n\n      if (this.simpleUrl) {\n        // We've gone down a rabbit hole of passing injectScript the path, so let's\n        // just pull the sheet_id out of the path like the least efficient worker bees\n        if (path.indexOf('/list/') !== -1) {\n          script.src = this.endpoint + '/' + this.key + '-' + path.split('/')[4];\n        } else {\n          script.src = this.endpoint + '/' + this.key;\n        }\n      } else {\n        script.src = this.endpoint + url;\n      }\n\n      if (this.parameterize) {\n        script.src = this.parameterize + encodeURIComponent(script.src);\n      }\n\n      this.log('Injecting', script.src);\n      document.getElementsByTagName('script')[0].parentNode.appendChild(script);\n    },\n\n    /*\n      This will only run if tabletop is being run in node.js\n    */\n    serverSideFetch: function serverSideFetch(path, callback) {\n      var self = this;\n      this.log('Fetching', this.endpoint + path);\n      request({\n        url: this.endpoint + path,\n        json: true\n      }, function (err, resp, body) {\n        if (err) {\n          return console.error(err);\n        }\n\n        callback.call(self, body);\n      });\n    },\n\n    /*\n      Is this a sheet you want to pull?\n      If { wanted: [\"Sheet1\"] } has been specified, only Sheet1 is imported\n      Pulls all sheets if none are specified\n    */\n    isWanted: function isWanted(sheetName) {\n      if (this.wanted.length === 0) {\n        return true;\n      } else {\n        return ttIndexOf(this.wanted, sheetName) !== -1;\n      }\n    },\n\n    /*\n      What gets send to the callback\n      if simpleSheet === true, then don't return an array of Tabletop.this.models,\n      only return the first one's elements\n    */\n    data: function data() {\n      // If the instance is being queried before the data's been fetched\n      // then return undefined.\n      if (this.modelNames.length === 0) {\n        return undefined;\n      }\n\n      if (this.simpleSheet) {\n        if (this.modelNames.length > 1 && this.debug) {\n          this.log('WARNING You have more than one sheet but are using simple sheet mode! Don\\'t blame me when something goes wrong.');\n        }\n\n        return this.models[this.modelNames[0]].all();\n      } else {\n        return this.models;\n      }\n    },\n\n    /*\n      Add another sheet to the wanted list\n    */\n    addWanted: function addWanted(sheet) {\n      if (ttIndexOf(this.wanted, sheet) === -1) {\n        this.wanted.push(sheet);\n      }\n    },\n\n    /*\n      Load all worksheets of the spreadsheet, turning each into a Tabletop Model.\n      Need to use injectScript because the worksheet view that you're working from\n      doesn't actually include the data. The list-based feed (/feeds/list/key..) does, though.\n      Calls back to loadSheet in order to get the real work done.\n       Used as a callback for the worksheet-based JSON\n    */\n    loadSheets: function loadSheets(data) {\n      var i, ilen;\n      var toLoad = [];\n      this.googleSheetName = data.feed.title.$t;\n      this.foundSheetNames = [];\n\n      for (i = 0, ilen = data.feed.entry.length; i < ilen; i++) {\n        this.foundSheetNames.push(data.feed.entry[i].title.$t); // Only pull in desired sheets to reduce loading\n\n        if (this.isWanted(data.feed.entry[i].content.$t)) {\n          var linkIdx = data.feed.entry[i].link.length - 1;\n          var sheetId = data.feed.entry[i].link[linkIdx].href.split('/').pop();\n          var jsonPath = '/feeds/list/' + this.key + '/' + sheetId + '/' + this.sheetPrivacy + '/values?alt=';\n\n          if (inNodeJS || supportsCORS) {\n            jsonPath += 'json';\n          } else {\n            jsonPath += 'json-in-script';\n          }\n\n          if (this.query) {\n            // Query Language Reference (0.7)\n            jsonPath += '&tq=' + this.query;\n          }\n\n          if (this.orderby) {\n            jsonPath += '&orderby=column:' + this.orderby.toLowerCase();\n          }\n\n          if (this.reverse) {\n            jsonPath += '&reverse=true';\n          }\n\n          toLoad.push(jsonPath);\n        }\n      }\n\n      this.sheetsToLoad = toLoad.length;\n\n      for (i = 0, ilen = toLoad.length; i < ilen; i++) {\n        this.requestData(toLoad[i], this.loadSheet);\n      }\n    },\n\n    /*\n      Access layer for the this.models\n      .sheets() gets you all of the sheets\n      .sheets('Sheet1') gets you the sheet named Sheet1\n    */\n    sheets: function sheets(sheetName) {\n      if (typeof sheetName === 'undefined') {\n        return this.models;\n      } else {\n        if (typeof this.models[sheetName] === 'undefined') {\n          // alert( \"Can't find \" + sheetName );\n          return;\n        } else {\n          return this.models[sheetName];\n        }\n      }\n    },\n    sheetReady: function sheetReady(model) {\n      this.models[model.name] = model;\n\n      if (ttIndexOf(this.modelNames, model.name) === -1) {\n        this.modelNames.push(model.name);\n      }\n\n      this.sheetsToLoad--;\n\n      if (this.sheetsToLoad === 0) {\n        this.doCallback();\n      }\n    },\n\n    /*\n      Parse a single list-based worksheet, turning it into a Tabletop Model\n       Used as a callback for the list-based JSON\n    */\n    loadSheet: function loadSheet(data) {\n      var that = this;\n      new Tabletop.Model({\n        data: data,\n        parseNumbers: this.parseNumbers,\n        postProcess: this.postProcess,\n        tabletop: this,\n        prettyColumnNames: this.prettyColumnNames,\n        onReady: function onReady() {\n          that.sheetReady(this);\n        }\n      });\n    },\n\n    /*\n      Execute the callback upon loading! Rely on this.data() because you might\n        only request certain pieces of data (i.e. simpleSheet mode)\n      Tests this.sheetsToLoad just in case a race condition happens to show up\n    */\n    doCallback: function doCallback() {\n      if (this.sheetsToLoad === 0) {\n        this.callback.apply(this.callbackContext || this, [this.data(), this]);\n      }\n    },\n    log: function log() {\n      if (this.debug) {\n        if (typeof console !== 'undefined' && typeof console.log !== 'undefined') {\n          Function.prototype.apply.apply(console.log, [console, arguments]);\n        }\n      }\n    }\n  };\n  /*\n    Tabletop.Model stores the attribute names and parses the worksheet data\n      to turn it into something worthwhile\n     Options should be in the format { data: XXX }, with XXX being the list-based worksheet\n  */\n\n  Tabletop.Model = function (options) {\n    var i, j, ilen, jlen;\n    this.columnNames = [];\n    this.column_names = this.columnNames; // jshint ignore:line\n\n    this.name = options.data.feed.title.$t;\n    this.tabletop = options.tabletop;\n    this.elements = [];\n    this.onReady = options.onReady;\n    this.raw = options.data; // A copy of the sheet's raw data, for accessing minutiae\n\n    if (typeof options.data.feed.entry === 'undefined') {\n      options.tabletop.log('Missing data for ' + this.name + ', make sure you didn\\'t forget column headers');\n      this.originalColumns = [];\n      this.elements = [];\n      this.onReady.call(this);\n      return;\n    }\n\n    for (var key in options.data.feed.entry[0]) {\n      if (/^gsx/.test(key)) {\n        this.columnNames.push(key.replace('gsx$', ''));\n      }\n    }\n\n    this.originalColumns = this.columnNames;\n    this.original_columns = this.originalColumns; // jshint ignore:line\n\n    for (i = 0, ilen = options.data.feed.entry.length; i < ilen; i++) {\n      var source = options.data.feed.entry[i];\n      var element = {};\n\n      for (j = 0, jlen = this.columnNames.length; j < jlen; j++) {\n        var cell = source['gsx$' + this.columnNames[j]];\n\n        if (typeof cell !== 'undefined') {\n          if (options.parseNumbers && cell.$t !== '' && !isNaN(cell.$t)) {\n            element[this.columnNames[j]] = +cell.$t;\n          } else {\n            element[this.columnNames[j]] = cell.$t;\n          }\n        } else {\n          element[this.columnNames[j]] = '';\n        }\n      }\n\n      if (element.rowNumber === undefined) {\n        element.rowNumber = i + 1;\n      }\n\n      if (options.postProcess) {\n        options.postProcess(element);\n      }\n\n      this.elements.push(element);\n    }\n\n    if (options.prettyColumnNames) {\n      this.fetchPrettyColumns();\n    } else {\n      this.onReady.call(this);\n    }\n  };\n\n  Tabletop.Model.prototype = {\n    /*\n      Returns all of the elements (rows) of the worksheet as objects\n    */\n    all: function all() {\n      return this.elements;\n    },\n    fetchPrettyColumns: function fetchPrettyColumns() {\n      if (!this.raw.feed.link[3]) {\n        return this.ready();\n      }\n\n      var cellurl = this.raw.feed.link[3].href.replace('/feeds/list/', '/feeds/cells/').replace('https://spreadsheets.google.com', '');\n      var that = this;\n      this.tabletop.requestData(cellurl, function (data) {\n        that.loadPrettyColumns(data);\n      });\n    },\n    ready: function ready() {\n      this.onReady.call(this);\n    },\n\n    /*\n     * Store column names as an object\n     * with keys of Google-formatted \"columnName\"\n     * and values of human-readable \"Column name\"\n     */\n    loadPrettyColumns: function loadPrettyColumns(data) {\n      var prettyColumns = {};\n      var columnNames = this.columnNames;\n      var i = 0;\n      var l = columnNames.length;\n\n      for (; i < l; i++) {\n        if (typeof data.feed.entry[i].content.$t !== 'undefined') {\n          prettyColumns[columnNames[i]] = data.feed.entry[i].content.$t;\n        } else {\n          prettyColumns[columnNames[i]] = columnNames[i];\n        }\n      }\n\n      this.prettyColumns = prettyColumns;\n      this.pretty_columns = this.prettyColumns; // jshint ignore:line\n\n      this.prettifyElements();\n      this.ready();\n    },\n\n    /*\n     * Go through each row, substitutiting\n     * Google-formatted \"columnName\"\n     * with human-readable \"Column name\"\n     */\n    prettifyElements: function prettifyElements() {\n      var prettyElements = [],\n          orderedPrettyNames = [],\n          i,\n          j,\n          ilen,\n          jlen;\n\n      for (j = 0, jlen = this.columnNames.length; j < jlen; j++) {\n        orderedPrettyNames.push(this.prettyColumns[this.columnNames[j]]);\n      }\n\n      for (i = 0, ilen = this.elements.length; i < ilen; i++) {\n        var newElement = {};\n\n        for (j = 0, jlen = this.columnNames.length; j < jlen; j++) {\n          var newColumnName = this.prettyColumns[this.columnNames[j]];\n          newElement[newColumnName] = this.elements[i][this.columnNames[j]];\n        }\n\n        prettyElements.push(newElement);\n      }\n\n      this.elements = prettyElements;\n      this.columnNames = orderedPrettyNames;\n    },\n\n    /*\n      Return the elements as an array of arrays, instead of an array of objects\n    */\n    toArray: function toArray() {\n      var array = [],\n          i,\n          j,\n          ilen,\n          jlen;\n\n      for (i = 0, ilen = this.elements.length; i < ilen; i++) {\n        var row = [];\n\n        for (j = 0, jlen = this.columnNames.length; j < jlen; j++) {\n          row.push(this.elements[i][this.columnNames[j]]);\n        }\n\n        array.push(row);\n      }\n\n      return array;\n    }\n  };\n\n  if (typeof module !== 'undefined' && module.exports) {\n    //don't just use inNodeJS, we may be in Browserify\n    module.exports = Tabletop;\n  } else if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return Tabletop;\n    });\n  } else {\n    window.Tabletop = Tabletop;\n  }\n})();","map":null,"metadata":{},"sourceType":"script"}