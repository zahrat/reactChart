{"ast":null,"code":"/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar jws = require('jws');\n\nvar noop = require('lodash.noop');\n/**\n * JWTAccess service account credentials.\n *\n * Create a new access token by using the credential to create a new JWT token\n * that's recognized as the access token.\n *\n * @param {string=} email the service account email address.\n * @param {string=} key the private key that will be used to sign the token.\n * @constructor\n */\n\n\nfunction JWTAccess(email, key) {\n  this.email = email;\n  this.key = key;\n}\n/**\n * Indicates whether the credential requires scopes to be created by calling\n * createdScoped before use.\n *\n * @return {boolean} always false\n */\n\n\nJWTAccess.prototype.createScopedRequired = function () {\n  // JWT Header authentication does not use scopes.\n  return false;\n};\n/**\n * Get a non-expired access token, after refreshing if necessary\n *\n * @param {string} authURI the URI being authorized\n * @param {function} metadataCb a callback invoked with the jwt\n *                   request metadata.\n */\n\n\nJWTAccess.prototype.getRequestMetadata = function (authURI, metadataCb) {\n  var iat = Math.floor(new Date().getTime() / 1000);\n  var exp = iat + 3600; // 3600 seconds = 1 hour\n  // The payload used for signed JWT headers has:\n  // iss == sub == <client email>\n  // aud == <the authorization uri>\n\n  var payload = {\n    iss: this.email,\n    sub: this.email,\n    aud: authURI,\n    exp: exp,\n    iat: iat\n  };\n  var assertion = {\n    header: {\n      alg: 'RS256',\n      typ: 'JWT'\n    },\n    payload: payload,\n    secret: this.key\n  }; // Sign the jwt and invoke metadataCb with it.\n\n  return this._signJWT(assertion, function (err, signedJWT) {\n    if (!err) {\n      return metadataCb(null, {\n        'Authorization': 'Bearer ' + signedJWT\n      });\n    } else {\n      return metadataCb(err, null);\n    }\n  });\n};\n/**\n * Create a JWTAccess credentials instance using the given input options.\n * @param {object=} json The input object.\n * @param {function=} opt_callback Optional callback.\n */\n\n\nJWTAccess.prototype.fromJSON = function (json, opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n\n  if (!json) {\n    done(new Error('Must pass in a JSON object containing the service account auth settings.'));\n    return;\n  }\n\n  if (!json.client_email) {\n    done(new Error('The incoming JSON object does not contain a client_email field'));\n    return;\n  }\n\n  if (!json.private_key) {\n    done(new Error('The incoming JSON object does not contain a private_key field'));\n    return;\n  } // Extract the relevant information from the json key file.\n\n\n  that.email = json.client_email;\n  that.key = json.private_key;\n  that.projectId = json.project_id;\n  done();\n};\n/**\n * Create a JWTAccess credentials instance using the given input stream.\n * @param {object=} stream The input stream.\n * @param {function=} opt_callback Optional callback.\n */\n\n\nJWTAccess.prototype.fromStream = function (stream, opt_callback) {\n  var that = this;\n  var done = opt_callback || noop;\n\n  if (!stream) {\n    process.nextTick(function () {\n      done(new Error('Must pass in a stream containing the service account auth settings.'));\n    });\n    return;\n  }\n\n  var s = '';\n  stream.setEncoding('utf8');\n  stream.on('data', function (chunk) {\n    s += chunk;\n  });\n  stream.on('end', function () {\n    try {\n      var data = JSON.parse(s);\n      that.fromJSON(data, opt_callback);\n    } catch (err) {\n      done(err);\n    }\n  });\n};\n/**\n * Sign the JWT object, returning any errors in the callback.\n *\n * signedJwtFn is a callback function(err, signedJWT); it is called with an\n * error if there is an exception during signing.\n *\n * @param  {object}   assertion   The assertion to sign\n * @param  {Function} signedJwtFn  fn(err, signedJWT)\n */\n\n\nJWTAccess.prototype._signJWT = function (assertion, signedJwtFn) {\n  try {\n    return signedJwtFn(null, jws.sign(assertion));\n  } catch (err) {\n    return signedJwtFn(err);\n  }\n};\n/**\n * Export JWTAccess.\n */\n\n\nmodule.exports = JWTAccess;","map":null,"metadata":{},"sourceType":"script"}