{"ast":null,"code":"/**\n * Copyright 2012 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar AuthClient = require('./authclient.js');\n\nvar LoginTicket = require('./loginticket.js');\n\nvar noop = require('lodash.noop');\n\nvar PemVerifier = require('./../pemverifier.js');\n\nvar querystring = require('querystring');\n\nvar util = require('util');\n\nvar certificateCache = null;\nvar certificateExpiry = null;\n/**\n * Handles OAuth2 flow for Google APIs.\n *\n * @param {string} clientId The authentication client ID.\n * @param {string} clientSecret The authentication client secret.\n * @param {string} redirectUri The URI to redirect to after completing the auth request.\n * @param {Object} opt_opts optional options for overriding the given parameters.\n * @constructor\n */\n\nfunction OAuth2Client(clientId, clientSecret, redirectUri, opt_opts) {\n  OAuth2Client.super_.call(this);\n  this.clientId_ = clientId;\n  this.clientSecret_ = clientSecret;\n  this.redirectUri_ = redirectUri;\n  this.opts = opt_opts || {};\n  this.credentials = {};\n}\n/**\n * Inherit from AuthClient.\n */\n\n\nutil.inherits(OAuth2Client, AuthClient);\n/**\n * The base URL for auth endpoints.\n * @const\n * @private\n */\n\nOAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/auth';\n/**\n * The base endpoint for token retrieval.\n * @const\n * @private\n */\n\nOAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://accounts.google.com/o/oauth2/token';\n/**\n * The base endpoint to revoke tokens.\n * @const\n * @private\n */\n\nOAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://accounts.google.com/o/oauth2/revoke';\n/**\n * Google Sign on certificates.\n * @const\n * @private\n */\n\nOAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n/**\n * Clock skew - five minutes in seconds\n * @const\n * @private\n */\n\nOAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * Max Token Lifetime is one day in seconds\n * @const\n * @private\n */\n\nOAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n/**\n * The allowed oauth token issuers.\n * @const\n * @private\n */\n\nOAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];\n/**\n * Generates URL for consent page landing.\n * @param {object=} opt_opts Options.\n * @return {string} URL to consent page.\n */\n\nOAuth2Client.prototype.generateAuthUrl = function (opt_opts) {\n  var opts = opt_opts || {};\n  opts.response_type = opts.response_type || 'code';\n  opts.client_id = opts.client_id || this.clientId_;\n  opts.redirect_uri = opts.redirect_uri || this.redirectUri_; // Allow scopes to be passed either as array or a string\n\n  if (opts.scope instanceof Array) {\n    opts.scope = opts.scope.join(' ');\n  }\n\n  var rootUrl = this.opts.authBaseUrl || OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n  return rootUrl + '?' + querystring.stringify(opts);\n};\n/**\n * Gets the access token for the given code.\n * @param {string} code The authorization code.\n * @param {function=} opt_callback Optional callback fn.\n */\n\n\nOAuth2Client.prototype.getToken = function (code, opt_callback) {\n  var uri = this.opts.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n  var values = {\n    code: code,\n    client_id: this.clientId_,\n    client_secret: this.clientSecret_,\n    redirect_uri: this.redirectUri_,\n    grant_type: 'authorization_code'\n  };\n  this.transporter.request({\n    method: 'POST',\n    uri: uri,\n    form: values,\n    json: true\n  }, function (err, tokens, response) {\n    if (!err && tokens && tokens.expires_in) {\n      tokens.expiry_date = new Date().getTime() + tokens.expires_in * 1000;\n      delete tokens.expires_in;\n    }\n\n    var done = opt_callback || noop;\n    done(err, tokens, response);\n  });\n};\n/**\n * Refreshes the access token.\n * @param {string} refresh_token Existing refresh token.\n * @param {function=} opt_callback Optional callback.\n * @private\n */\n\n\nOAuth2Client.prototype.refreshToken_ = function (refresh_token, opt_callback) {\n  var uri = this.opts.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n  var values = {\n    refresh_token: refresh_token,\n    client_id: this.clientId_,\n    client_secret: this.clientSecret_,\n    grant_type: 'refresh_token'\n  }; // request for new token\n\n  return this.transporter.request({\n    method: 'POST',\n    uri: uri,\n    form: values,\n    json: true\n  }, function (err, tokens, response) {\n    if (!err && tokens && tokens.expires_in) {\n      tokens.expiry_date = new Date().getTime() + tokens.expires_in * 1000;\n      delete tokens.expires_in;\n    }\n\n    var done = opt_callback || noop;\n    done(err, tokens, response);\n  });\n};\n/**\n * Retrieves the access token using refresh token\n *\n * @deprecated use getRequestMetadata instead.\n * @param {function} callback callback\n */\n\n\nOAuth2Client.prototype.refreshAccessToken = function (callback) {\n  var that = this;\n\n  if (!this.credentials.refresh_token) {\n    callback(new Error('No refresh token is set.'), null);\n    return;\n  }\n\n  this.refreshToken_(this.credentials.refresh_token, function (err, result, response) {\n    if (err) {\n      callback(err, null, response);\n    } else {\n      var tokens = result;\n      tokens.refresh_token = that.credentials.refresh_token;\n      that.credentials = tokens;\n      callback(null, that.credentials, response);\n    }\n  });\n};\n/**\n * Get a non-expired access token, after refreshing if necessary\n *\n * @param {function} callback Callback to call with the access token\n */\n\n\nOAuth2Client.prototype.getAccessToken = function (callback) {\n  var credentials = this.credentials;\n  var expiryDate = credentials.expiry_date; // if no expiry time, assume it's not expired\n\n  var isTokenExpired = expiryDate ? expiryDate <= new Date().getTime() : false;\n\n  if (!credentials.access_token && !credentials.refresh_token) {\n    return callback(new Error('No access or refresh token is set.'), null);\n  }\n\n  var shouldRefresh = !credentials.access_token || isTokenExpired;\n\n  if (shouldRefresh && credentials.refresh_token) {\n    if (!this.credentials.refresh_token) {\n      return callback(new Error('No refresh token is set.'), null);\n    }\n\n    this.refreshAccessToken(function (err, tokens, response) {\n      if (err) {\n        return callback(err, null, response);\n      }\n\n      if (!tokens || tokens && !tokens.access_token) {\n        return callback(new Error('Could not refresh access token.'), null, response);\n      }\n\n      return callback(null, tokens.access_token, response);\n    });\n  } else {\n    return callback(null, credentials.access_token, null);\n  }\n};\n/**\n * getRequestMetadata obtains auth metadata to be used by requests.\n *\n * getRequestMetadata is the main authentication interface.  It takes an\n * optional uri which when present is the endpoint being accessed, and a\n * callback func(err, metadata_obj, response) where metadata_obj contains\n * authorization metadata fields and response is an optional response object.\n *\n * In OAuth2Client, metadata_obj has the form.\n *\n * {Authorization: 'Bearer <access_token_value>'}\n *\n * @param {string} opt_uri the Uri being authorized\n * @param {function} metadataCb the func described above\n */\n\n\nOAuth2Client.prototype.getRequestMetadata = function (opt_uri, metadataCb) {\n  var that = this;\n  var thisCreds = this.credentials;\n\n  if (!thisCreds.access_token && !thisCreds.refresh_token) {\n    return metadataCb(new Error('No access or refresh token is set.'), null);\n  } // if no expiry time, assume it's not expired\n\n\n  var expiryDate = thisCreds.expiry_date;\n  var isTokenExpired = expiryDate ? expiryDate <= new Date().getTime() : false;\n\n  if (thisCreds.access_token && !isTokenExpired) {\n    thisCreds.token_type = thisCreds.token_type || 'Bearer';\n    var headers = {\n      'Authorization': thisCreds.token_type + ' ' + thisCreds.access_token\n    };\n    return metadataCb(null, headers, null);\n  }\n\n  return this.refreshToken_(thisCreds.refresh_token, function (err, tokens, response) {\n    if (err) {\n      return metadataCb(err, null, response);\n    } else {\n      if (!tokens || tokens && !tokens.access_token) {\n        return metadataCb(new Error('Could not refresh access token.'), null, response);\n      }\n\n      var credentials = that.credentials;\n      credentials.token_type = credentials.token_type || 'Bearer';\n      tokens.refresh_token = credentials.refresh_token;\n      that.credentials = tokens;\n      var headers = {\n        'Authorization': credentials.token_type + ' ' + tokens.access_token\n      };\n      return metadataCb(err, headers, response);\n    }\n  });\n};\n/**\n * Revokes the access given to token.\n * @param {string} token The existing token to be revoked.\n * @param {function=} opt_callback Optional callback fn.\n */\n\n\nOAuth2Client.prototype.revokeToken = function (token, opt_callback) {\n  this.transporter.request({\n    uri: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' + querystring.stringify({\n      token: token\n    }),\n    json: true\n  }, opt_callback);\n};\n/**\n * Revokes access token and clears the credentials object\n * @param  {Function=} callback callback\n */\n\n\nOAuth2Client.prototype.revokeCredentials = function (callback) {\n  var token = this.credentials.access_token;\n  this.credentials = {};\n\n  if (token) {\n    this.revokeToken(token, callback);\n  } else {\n    callback(new Error('No access token to revoke.'), null);\n  }\n};\n/**\n * Provides a request implementation with OAuth 2.0 flow.\n * If credentials have a refresh_token, in cases of HTTP\n * 401 and 403 responses, it automatically asks for a new\n * access token and replays the unsuccessful request.\n * @param {object} opts Request options.\n * @param {function} callback callback.\n * @return {Request} Request object\n */\n\n\nOAuth2Client.prototype.request = function (opts, callback) {\n  /* jshint latedef:false */\n  var that = this; // Callbacks will close over this to ensure that we only retry once\n\n  var retry = true; // Hook the callback routine to call the _postRequest method.\n\n  var postRequestCb = function postRequestCb(err, body, resp) {\n    var statusCode = resp && resp.statusCode; // Automatically retry 401 and 403 responses\n    // if err is set and is unrelated to response\n    // then getting credentials failed, and retrying won't help\n\n    if (retry && (statusCode === 401 || statusCode === 403) && (!err || err.code === statusCode)) {\n      /* It only makes sense to retry once, because the retry is intended to\n       * handle expiration-related failures. If refreshing the token does not\n       * fix the failure, then refreshing again probably won't help */\n      retry = false; // Force token refresh\n\n      that.refreshAccessToken(function () {\n        that.getRequestMetadata(unusedUri, authCb);\n      });\n    } else {\n      that._postRequest(err, body, resp, callback);\n    }\n  };\n\n  var authCb = function authCb(err, headers, response) {\n    if (err) {\n      postRequestCb(err, null, response);\n    } else {\n      if (headers) {\n        opts.headers = opts.headers || {};\n        opts.headers.Authorization = headers.Authorization;\n      }\n\n      return that._makeRequest(opts, postRequestCb);\n    }\n  };\n\n  var unusedUri = null;\n  return this.getRequestMetadata(unusedUri, authCb);\n};\n/**\n * Makes a request without paying attention to refreshing or anything\n * Assumes that all credentials are set correctly.\n * @param  {object}   opts     Options for request\n * @param  {Function} callback callback function\n * @return {Request}           The request object created\n */\n\n\nOAuth2Client.prototype._makeRequest = function (opts, callback) {\n  return this.transporter.request(opts, callback);\n};\n/**\n * Allows inheriting classes to inspect and alter the request result.\n * @param {object} err Error result.\n * @param {object} result The result.\n * @param {object} result The HTTP response.\n * @param {Function} callback The callback.\n * @private\n */\n\n\nOAuth2Client.prototype._postRequest = function (err, result, response, callback) {\n  callback(err, result, response);\n};\n/**\n * Verify id token is token by checking the certs and audience\n * @param {string} idToken ID Token.\n * @param {(string|Array.<string>)} audience The audience to verify against the ID Token\n * @param {function=} callback Callback supplying GoogleLogin if successful\n */\n\n\nOAuth2Client.prototype.verifyIdToken = function (idToken, audience, callback) {\n  if (!idToken || !callback) {\n    throw new Error('The verifyIdToken method requires both ' + 'an ID Token and a callback method');\n  }\n\n  this.getFederatedSignonCerts(function (err, certs) {\n    if (err) {\n      callback(err, null);\n    }\n\n    var login;\n\n    try {\n      login = this.verifySignedJwtWithCerts(idToken, certs, audience, OAuth2Client.ISSUERS_);\n    } catch (err) {\n      callback(err);\n      return;\n    }\n\n    callback(null, login);\n  }.bind(this));\n};\n/**\n * Gets federated sign-on certificates to use for verifying identity tokens.\n * Returns certs as array structure, where keys are key ids, and values\n * are PEM encoded certificates.\n * @param {function=} callback Callback supplying the certificates\n */\n\n\nOAuth2Client.prototype.getFederatedSignonCerts = function (callback) {\n  var nowTime = new Date().getTime();\n\n  if (certificateExpiry && nowTime < certificateExpiry.getTime()) {\n    callback(null, certificateCache);\n    return;\n  }\n\n  this.transporter.request({\n    method: 'GET',\n    uri: OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_,\n    json: true\n  }, function (err, body, response) {\n    if (err) {\n      callback('Failed to retrieve verification certificates: ' + err, null, response);\n      return;\n    }\n\n    var cacheControl = response.headers['cache-control'];\n    var cacheAge = -1;\n\n    if (cacheControl) {\n      var pattern = new RegExp('max-age=([0-9]*)');\n      var regexResult = pattern.exec(cacheControl);\n\n      if (regexResult.length === 2) {\n        // Cache results with max-age (in seconds)\n        cacheAge = regexResult[1] * 1000; // milliseconds\n      }\n    }\n\n    var now = new Date();\n    certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n    certificateCache = body;\n    callback(null, body, response);\n  });\n};\n/**\n * Verify the id token is signed with the correct certificate\n * and is from the correct audience.\n * @param {string} jwt The jwt to verify (The ID Token in this case).\n * @param {array} certs The array of certs to test the jwt against.\n * @param {(string|Array.<string>)} requiredAudience The audience to test the jwt against.\n * @param {array} issuers The allowed issuers of the jwt (Optional).\n * @param {string} maxExpiry The max expiry the certificate can be (Optional).\n * @return {LoginTicket} Returns a LoginTicket on verification.\n */\n\n\nOAuth2Client.prototype.verifySignedJwtWithCerts = function (jwt, certs, requiredAudience, issuers, maxExpiry) {\n  if (!maxExpiry) {\n    maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n  }\n\n  var segments = jwt.split('.');\n\n  if (segments.length !== 3) {\n    throw new Error('Wrong number of segments in token: ' + jwt);\n  }\n\n  var signed = segments[0] + '.' + segments[1];\n  var signature = segments[2];\n  var envelope, payload;\n\n  try {\n    envelope = JSON.parse(this.decodeBase64(segments[0]));\n  } catch (err) {}\n\n  if (!envelope) {\n    throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n  }\n\n  try {\n    payload = JSON.parse(this.decodeBase64(segments[1]));\n  } catch (err) {}\n\n  if (!payload) {\n    throw new Error('Can\\'t parse token payload: ' + segments[1]);\n  }\n\n  if (!certs.hasOwnProperty(envelope.kid)) {\n    // If this is not present, then there's no reason to attempt verification\n    throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n  }\n\n  var pem = certs[envelope.kid];\n  var pemVerifier = new PemVerifier();\n  var verified = pemVerifier.verify(pem, signed, signature, 'base64');\n\n  if (!verified) {\n    throw new Error('Invalid token signature: ' + jwt);\n  }\n\n  if (!payload.iat) {\n    throw new Error('No issue time in token: ' + JSON.stringify(payload));\n  }\n\n  if (!payload.exp) {\n    throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n  }\n\n  var iat = parseInt(payload.iat, 10);\n  var exp = parseInt(payload.exp, 10);\n  var now = new Date().getTime() / 1000;\n\n  if (exp >= now + maxExpiry) {\n    throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n  }\n\n  var earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n  var latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n  if (now < earliest) {\n    throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));\n  }\n\n  if (now > latest) {\n    throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));\n  }\n\n  if (issuers && issuers.indexOf(payload.iss) < 0) {\n    throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);\n  } // Check the audience matches if we have one\n\n\n  if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n    var aud = payload.aud;\n    var audVerified = false; //If the requiredAudience is an array, check if it contains token audience\n\n    if (requiredAudience.constructor === Array) {\n      audVerified = requiredAudience.indexOf(aud) > -1;\n    } else {\n      audVerified = aud === requiredAudience;\n    }\n\n    if (!audVerified) {\n      throw new Error('Wrong recipient, payload audience != requiredAudience');\n    }\n  }\n\n  return new LoginTicket(envelope, payload);\n};\n/**\n * This is a utils method to decode a base64 string\n * @param {string} b64String The string to base64 decode\n * @return {string} The decoded string\n */\n\n\nOAuth2Client.prototype.decodeBase64 = function (b64String) {\n  var buffer = new Buffer(b64String, 'base64');\n  return buffer.toString('utf8');\n};\n/**\n * Export OAuth2Client.\n */\n\n\nmodule.exports = OAuth2Client;","map":null,"metadata":{},"sourceType":"script"}